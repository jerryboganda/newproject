using Microsoft.EntityFrameworkCore;
using StreamVault.Application.Videos.DTOs;
using StreamVault.Domain.Entities;
using StreamVault.Infrastructure.Data;
using System.Text.Json;

namespace StreamVault.Application.Videos;

public class VideoChapterService : IVideoChapterService
{
    private readonly StreamVaultDbContext _dbContext;
    private readonly ILogger<VideoChapterService> _logger;

    public VideoChapterService(StreamVaultDbContext dbContext, ILogger<VideoChapterService> logger)
    {
        _dbContext = dbContext;
        _logger = logger;
    }

    public async Task<VideoChapterDto> CreateChapterAsync(Guid videoId, Guid userId, Guid tenantId, CreateChapterRequest request)
    {
        // Verify video exists and user has permission
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        if (video.UserId != userId)
            throw new Exception("Only video owner can create chapters");

        // Validate time ranges
        if (request.StartTime < TimeSpan.Zero || request.StartTime >= TimeSpan.FromSeconds(video.DurationSeconds))
            throw new Exception("Invalid start time");

        if (request.EndTime.HasValue && (request.EndTime.Value <= request.StartTime || 
            request.EndTime.Value > TimeSpan.FromSeconds(video.DurationSeconds)))
            throw new Exception("Invalid end time");

        var chapter = new VideoChapter
        {
            Id = Guid.NewGuid(),
            VideoId = videoId,
            Title = request.Title,
            Description = request.Description,
            StartTime = request.StartTime,
            EndTime = request.EndTime,
            ThumbnailUrl = request.ThumbnailUrl,
            Tags = string.Join(",", request.Tags),
            IsHidden = request.IsHidden,
            Order = request.Order,
            IsAutoGenerated = false,
            CreatedAt = DateTimeOffset.UtcNow,
            UpdatedAt = DateTimeOffset.UtcNow
        };

        _dbContext.VideoChapters.Add(chapter);
        await _dbContext.SaveChangesAsync();

        return MapToChapterDto(chapter);
    }

    public async Task<bool> UpdateChapterAsync(Guid chapterId, Guid userId, Guid tenantId, UpdateChapterRequest request)
    {
        var chapter = await _dbContext.VideoChapters
            .Include(c => c.Video)
            .FirstOrDefaultAsync(c => c.Id == chapterId);

        if (chapter == null || chapter.Video.TenantId != tenantId)
            throw new Exception("Chapter not found");

        if (chapter.Video.UserId != userId)
            throw new Exception("Only video owner can update chapters");

        // Validate time ranges if provided
        if (request.StartTime.HasValue)
        {
            if (request.StartTime.Value < TimeSpan.Zero || 
                request.StartTime.Value >= TimeSpan.FromSeconds(chapter.Video.DurationSeconds))
                throw new Exception("Invalid start time");
        }

        if (request.EndTime.HasValue)
        {
            var startTime = request.StartTime ?? chapter.StartTime;
            if (request.EndTime.Value <= startTime || 
                request.EndTime.Value > TimeSpan.FromSeconds(chapter.Video.DurationSeconds))
                throw new Exception("Invalid end time");
        }

        if (request.Title != null)
            chapter.Title = request.Title;
        
        if (request.Description != null)
            chapter.Description = request.Description;
        
        if (request.StartTime.HasValue)
            chapter.StartTime = request.StartTime.Value;
        
        if (request.EndTime.HasValue)
            chapter.EndTime = request.EndTime.Value;
        
        if (request.ThumbnailUrl != null)
            chapter.ThumbnailUrl = request.ThumbnailUrl;
        
        if (request.Tags != null)
            chapter.Tags = string.Join(",", request.Tags);
        
        if (request.IsHidden.HasValue)
            chapter.IsHidden = request.IsHidden.Value;
        
        if (request.Order.HasValue)
            chapter.Order = request.Order.Value;

        chapter.UpdatedAt = DateTimeOffset.UtcNow;

        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<bool> DeleteChapterAsync(Guid chapterId, Guid userId, Guid tenantId)
    {
        var chapter = await _dbContext.VideoChapters
            .Include(c => c.Video)
            .FirstOrDefaultAsync(c => c.Id == chapterId);

        if (chapter == null || chapter.Video.TenantId != tenantId)
            throw new Exception("Chapter not found");

        if (chapter.Video.UserId != userId)
            throw new Exception("Only video owner can delete chapters");

        _dbContext.VideoChapters.Remove(chapter);
        await _dbContext.SaveChangesAsync();

        return true;
    }

    public async Task<List<VideoChapterDto>> GetVideoChaptersAsync(Guid videoId, Guid userId, Guid tenantId)
    {
        // Verify video exists
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        var chapters = await _dbContext.VideoChapters
            .Where(c => c.VideoId == videoId && !c.IsHidden)
            .OrderBy(c => c.Order)
            .ThenBy(c => c.StartTime)
            .ToListAsync();

        return chapters.Select(MapToChapterDto).ToList();
    }

    public async Task<VideoChapterDto?> GetChapterAsync(Guid chapterId, Guid userId, Guid tenantId)
    {
        var chapter = await _dbContext.VideoChapters
            .Include(c => c.Video)
            .FirstOrDefaultAsync(c => c.Id == chapterId);

        if (chapter == null || chapter.Video.TenantId != tenantId)
            return null;

        return MapToChapterDto(chapter);
    }

    public async Task<bool> ReorderChaptersAsync(Guid videoId, Guid userId, Guid tenantId, List<Guid> chapterIds)
    {
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        if (video.UserId != userId)
            throw new Exception("Only video owner can reorder chapters");

        var chapters = await _dbContext.VideoChapters
            .Where(c => c.VideoId == videoId)
            .ToListAsync();

        for (int i = 0; i < chapterIds.Count && i < chapters.Count; i++)
        {
            var chapter = chapters.FirstOrDefault(c => c.Id == chapterIds[i]);
            if (chapter != null)
            {
                chapter.Order = i + 1;
                chapter.UpdatedAt = DateTimeOffset.UtcNow;
            }
        }

        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<VideoMarkerDto> AddMarkerAsync(Guid videoId, Guid userId, Guid tenantId, CreateMarkerRequest request)
    {
        // Verify video exists
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        // Validate time
        if (request.Time < TimeSpan.Zero || request.Time >= TimeSpan.FromSeconds(video.DurationSeconds))
            throw new Exception("Invalid marker time");

        var marker = new VideoMarker
        {
            Id = Guid.NewGuid(),
            VideoId = videoId,
            UserId = userId,
            Time = request.Time,
            Title = request.Title,
            Description = request.Description,
            Type = request.Type,
            Color = request.Color,
            IsPrivate = request.IsPrivate,
            Metadata = request.Metadata?.ToString(),
            CreatedAt = DateTimeOffset.UtcNow,
            UpdatedAt = DateTimeOffset.UtcNow
        };

        _dbContext.VideoMarkers.Add(marker);
        await _dbContext.SaveChangesAsync();

        return await MapToMarkerDto(marker);
    }

    public async Task<bool> UpdateMarkerAsync(Guid markerId, Guid userId, Guid tenantId, UpdateMarkerRequest request)
    {
        var marker = await _dbContext.VideoMarkers
            .Include(m => m.Video)
            .FirstOrDefaultAsync(m => m.Id == markerId);

        if (marker == null || marker.Video.TenantId != tenantId)
            throw new Exception("Marker not found");

        if (marker.UserId != userId)
            throw new Exception("Only marker owner can update it");

        // Validate time if provided
        if (request.Time.HasValue)
        {
            if (request.Time.Value < TimeSpan.Zero || 
                request.Time.Value >= TimeSpan.FromSeconds(marker.Video.DurationSeconds))
                throw new Exception("Invalid marker time");
        }

        if (request.Time.HasValue)
            marker.Time = request.Time.Value;
        
        if (request.Title != null)
            marker.Title = request.Title;
        
        if (request.Description != null)
            marker.Description = request.Description;
        
        if (request.Type != null)
            marker.Type = request.Type;
        
        if (request.Color != null)
            marker.Color = request.Color;
        
        if (request.IsPrivate.HasValue)
            marker.IsPrivate = request.IsPrivate.Value;
        
        if (request.Metadata != null)
            marker.Metadata = request.Metadata.ToString();

        marker.UpdatedAt = DateTimeOffset.UtcNow;

        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<bool> DeleteMarkerAsync(Guid markerId, Guid userId, Guid tenantId)
    {
        var marker = await _dbContext.VideoMarkers
            .Include(m => m.Video)
            .FirstOrDefaultAsync(m => m.Id == markerId);

        if (marker == null || marker.Video.TenantId != tenantId)
            throw new Exception("Marker not found");

        if (marker.UserId != userId)
            throw new Exception("Only marker owner can delete it");

        _dbContext.VideoMarkers.Remove(marker);
        await _dbContext.SaveChangesAsync();

        return true;
    }

    public async Task<List<VideoMarkerDto>> GetVideoMarkersAsync(Guid videoId, Guid userId, Guid tenantId)
    {
        // Verify video exists
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        var markers = await _dbContext.VideoMarkers
            .Include(m => m.User)
            .Where(m => m.VideoId == videoId && (m.UserId == userId || !m.IsPrivate))
            .OrderBy(m => m.Time)
            .ToListAsync();

        var result = new List<VideoMarkerDto>();
        foreach (var marker in markers)
        {
            result.Add(await MapToMarkerDto(marker));
        }

        return result;
    }

    public async Task<List<VideoMarkerDto>> GetMarkersByTypeAsync(Guid videoId, Guid userId, Guid tenantId, string type)
    {
        // Verify video exists
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        var markers = await _dbContext.VideoMarkers
            .Include(m => m.User)
            .Where(m => m.VideoId == videoId && m.Type == type && (m.UserId == userId || !m.IsPrivate))
            .OrderBy(m => m.Time)
            .ToListAsync();

        var result = new List<VideoMarkerDto>();
        foreach (var marker in markers)
        {
            result.Add(await MapToMarkerDto(marker));
        }

        return result;
    }

    public async Task<VideoChapterDto> AutoGenerateChaptersAsync(Guid videoId, Guid userId, Guid tenantId)
    {
        // Verify video exists and user has permission
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        if (video.UserId != userId)
            throw new Exception("Only video owner can generate chapters");

        // Delete existing auto-generated chapters
        var existingAutoChapters = await _dbContext.VideoChapters
            .Where(c => c.VideoId == videoId && c.IsAutoGenerated)
            .ToListAsync();

        _dbContext.VideoChapters.RemoveRange(existingAutoChapters);

        // Simulate AI-based chapter generation
        // In production, this would use video analysis services
        var suggestedChapters = GenerateChapterSuggestions(video);

        foreach (var suggestion in suggestedChapters)
        {
            var chapter = new VideoChapter
            {
                Id = Guid.NewGuid(),
                VideoId = videoId,
                Title = suggestion.SuggestedTitle,
                StartTime = suggestion.StartTime,
                EndTime = suggestion.EndTime,
                IsHidden = false,
                Order = suggestedChapters.IndexOf(suggestion) + 1,
                IsAutoGenerated = true,
                CreatedAt = DateTimeOffset.UtcNow,
                UpdatedAt = DateTimeOffset.UtcNow
            };

            _dbContext.VideoChapters.Add(chapter);
        }

        await _dbContext.SaveChangesAsync();

        // Return the first generated chapter
        var firstChapter = await _dbContext.VideoChapters
            .Where(c => c.VideoId == videoId && c.IsAutoGenerated)
            .OrderBy(c => c.Order)
            .FirstOrDefaultAsync();

        return firstChapter != null ? MapToChapterDto(firstChapter) : 
            throw new Exception("Failed to generate chapters");
    }

    public async Task<bool> ImportChaptersAsync(Guid videoId, Guid userId, Guid tenantId, ImportChaptersRequest request)
    {
        // Verify video exists and user has permission
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        if (video.UserId != userId)
            throw new Exception("Only video owner can import chapters");

        // Remove existing chapters if requested
        if (request.ReplaceExisting)
        {
            var existingChapters = await _dbContext.VideoChapters
                .Where(c => c.VideoId == videoId)
                .ToListAsync();

            _dbContext.VideoChapters.RemoveRange(existingChapters);
        }

        // Parse and create chapters based on format
        var chapters = ParseChaptersFromContent(request.Content, request.Format, request.TimeOffset);

        foreach (var chapterData in chapters)
        {
            var chapter = new VideoChapter
            {
                Id = Guid.NewGuid(),
                VideoId = videoId,
                Title = chapterData.Title,
                Description = chapterData.Description,
                StartTime = chapterData.StartTime,
                EndTime = chapterData.EndTime,
                Order = chapterData.Order,
                IsAutoGenerated = false,
                CreatedAt = DateTimeOffset.UtcNow,
                UpdatedAt = DateTimeOffset.UtcNow
            };

            _dbContext.VideoChapters.Add(chapter);
        }

        await _dbContext.SaveChangesAsync();
        return true;
    }

    public async Task<string> ExportChaptersAsync(Guid videoId, Guid userId, Guid tenantId, string format = "json")
    {
        // Verify video exists
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        var chapters = await _dbContext.VideoChapters
            .Where(c => c.VideoId == videoId)
            .OrderBy(c => c.Order)
            .ThenBy(c => c.StartTime)
            .ToListAsync();

        var exportData = new ChapterExportDto
        {
            VideoId = videoId,
            VideoTitle = video.Title,
            Chapters = chapters.Select(MapToChapterDto).ToList(),
            TotalDuration = TimeSpan.FromSeconds(video.DurationSeconds),
            ChapterCount = chapters.Count,
            ExportedAt = DateTimeOffset.UtcNow
        };

        return format.ToLower() switch
        {
            "json" => JsonSerializer.Serialize(exportData, new JsonSerializerOptions { WriteIndented = true }),
            "csv" => ExportToCsv(exportData),
            "youtube" => ExportToYouTubeFormat(exportData),
            "vtt" => ExportToVttFormat(exportData),
            _ => throw new Exception($"Unsupported export format: {format}")
        };
    }

    public async Task<List<ChapterNavigationDto>> GetChapterNavigationAsync(Guid videoId, Guid userId, Guid tenantId)
    {
        // Verify video exists
        var video = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.Id == videoId && v.TenantId == tenantId);

        if (video == null)
            throw new Exception("Video not found");

        var chapters = await _dbContext.VideoChapters
            .Where(c => c.VideoId == videoId && !c.IsHidden)
            .OrderBy(c => c.Order)
            .ThenBy(c => c.StartTime)
            .ToListAsync();

        return chapters.Select(c => new ChapterNavigationDto
        {
            ChapterId = c.Id,
            Title = c.Title,
            StartTime = c.StartTime,
            EndTime = c.EndTime ?? TimeSpan.Zero,
            ThumbnailUrl = c.ThumbnailUrl,
            Order = c.Order,
            IsActive = false
        }).ToList();
    }

    public async Task<bool> SetChapterThumbnailAsync(Guid chapterId, Guid userId, Guid tenantId, string thumbnailUrl)
    {
        var chapter = await _dbContext.VideoChapters
            .Include(c => c.Video)
            .FirstOrDefaultAsync(c => c.Id == chapterId);

        if (chapter == null || chapter.Video.TenantId != tenantId)
            throw new Exception("Chapter not found");

        if (chapter.Video.UserId != userId)
            throw new Exception("Only video owner can update chapter thumbnail");

        chapter.ThumbnailUrl = thumbnailUrl;
        chapter.UpdatedAt = DateTimeOffset.UtcNow;

        await _dbContext.SaveChangesAsync();
        return true;
    }

    private VideoChapterDto MapToChapterDto(VideoChapter chapter)
    {
        return new VideoChapterDto
        {
            Id = chapter.Id,
            VideoId = chapter.VideoId,
            Title = chapter.Title,
            Description = chapter.Description,
            StartTime = chapter.StartTime,
            EndTime = chapter.EndTime,
            ThumbnailUrl = chapter.ThumbnailUrl,
            Tags = string.IsNullOrEmpty(chapter.Tags) ? new List<string>() : chapter.Tags.Split(',').ToList(),
            IsHidden = chapter.IsHidden,
            Order = chapter.Order,
            CreatedAt = chapter.CreatedAt,
            UpdatedAt = chapter.UpdatedAt,
            IsAutoGenerated = chapter.IsAutoGenerated
        };
    }

    private async Task<VideoMarkerDto> MapToMarkerDto(VideoMarker marker)
    {
        var user = await _dbContext.Users.FindAsync(marker.UserId);
        
        return new VideoMarkerDto
        {
            Id = marker.Id,
            VideoId = marker.VideoId,
            UserId = marker.UserId,
            Time = marker.Time,
            Title = marker.Title,
            Description = marker.Description,
            Type = marker.Type,
            Color = marker.Color,
            IsPrivate = marker.IsPrivate,
            CreatedAt = marker.CreatedAt,
            UpdatedAt = marker.UpdatedAt,
            Metadata = string.IsNullOrEmpty(marker.Metadata) ? null : JsonSerializer.Deserialize<Dictionary<string, object>>(marker.Metadata),
            User = new Auth.DTOs.UserDto
            {
                Id = user.Id,
                Email = user.Email,
                FirstName = user.FirstName,
                LastName = user.LastName,
                AvatarUrl = user.AvatarUrl
            }
        };
    }

    private List<ChapterSuggestionDto> GenerateChapterSuggestions(Video video)
    {
        // Simulate AI chapter generation
        var duration = TimeSpan.FromSeconds(video.DurationSeconds);
        var suggestions = new List<ChapterSuggestionDto>();

        // Generate chapters every 5 minutes for demonstration
        var chapterDuration = TimeSpan.FromMinutes(5);
        var current = TimeSpan.Zero;
        var chapterIndex = 1;

        while (current < duration)
        {
            var endTime = Math.Min(current + chapterDuration, duration);
            
            suggestions.Add(new ChapterSuggestionDto
            {
                StartTime = current,
                EndTime = endTime,
                SuggestedTitle = $"Chapter {chapterIndex}",
                Confidence = 0.8,
                Reason = "Auto-generated based on content analysis",
                Keywords = new List<string> { "auto", "generated" }
            });

            current = endTime;
            chapterIndex++;
        }

        return suggestions;
    }

    private List<CreateChapterRequest> ParseChaptersFromContent(string content, string format, TimeSpan? timeOffset)
    {
        // Simplified parsing - in production, implement proper parsers for each format
        var chapters = new List<CreateChapterRequest>();

        if (format.ToLower() == "json")
        {
            var importedChapters = JsonSerializer.Deserialize<List<VideoChapterDto>>(content);
            if (importedChapters != null)
            {
                foreach (var chapter in importedChapters)
                {
                    chapters.Add(new CreateChapterRequest
                    {
                        Title = chapter.Title,
                        Description = chapter.Description,
                        StartTime = chapter.StartTime.Add(timeOffset ?? TimeSpan.Zero),
                        EndTime = chapter.EndTime?.Add(timeOffset ?? TimeSpan.Zero),
                        Order = chapter.Order
                    });
                }
            }
        }

        return chapters;
    }

    private string ExportToCsv(ChapterExportDto data)
    {
        var csv = "Title,StartTime,EndTime,Description\n";
        foreach (var chapter in data.Chapters)
        {
            csv += $"\"{chapter.Title}\",{chapter.StartTime},{chapter.EndTime},\"{chapter.Description}\"\n";
        }
        return csv;
    }

    private string ExportToYouTubeFormat(ChapterExportDto data)
    {
        var youtube = "";
        foreach (var chapter in data.Chapters)
        {
            youtube += $"{chapter.StartTime:hh\\:mm\\:ss} {chapter.Title}\n";
        }
        return youtube;
    }

    private string ExportToVttFormat(ChapterExportDto data)
    {
        var vtt = "WEBVTT\n\n";
        foreach (var chapter in data.Chapters)
        {
            vtt += $"{chapter.StartTime:hh\\:mm\\:ss\\.fff} --> {chapter.EndTime:hh\\:mm\\:ss\\.fff}\n";
            vtt += $"{chapter.Title}\n\n";
        }
        return vtt;
    }
}

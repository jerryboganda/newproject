using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using StreamVault.Domain.Entities;
using StreamVault.Infrastructure.Data;

namespace StreamVault.Application.Services
{
    public interface ICaptionService
    {
        Task<Caption> CreateCaptionAsync(Guid videoId, string language, CaptionFormat format, string content, string? label = null);
        Task UpdateCaptionAsync(Guid captionId, string? content = null, string? label = null);
        Task DeleteCaptionAsync(Guid captionId);
        Task<Caption?> GetCaptionAsync(Guid captionId);
        Task<IEnumerable<Caption>> GetVideoCaptionsAsync(Guid videoId);
        Task<byte[]> ExportCaptionAsync(Guid captionId, CaptionFormat format);
        Task<Caption> ImportCaptionAsync(Guid videoId, Stream fileStream, CaptionFormat format, string language, string? label = null);
        Task<Caption> AutoGenerateCaptionAsync(Guid videoId, string language);
        Task<CaptionTrack> GetCaptionTrackAsync(Guid videoId, string language);
    }

    public class CaptionService : ICaptionService
    {
        private readonly StreamVaultDbContext _context;
        private readonly IVideoProcessingService _videoProcessingService;

        public CaptionService(StreamVaultDbContext context, IVideoProcessingService videoProcessingService)
        {
            _context = context;
            _videoProcessingService = videoProcessingService;
        }

        public async Task<Caption> CreateCaptionAsync(Guid videoId, string language, CaptionFormat format, string content, string? label = null)
        {
            var video = await _context.Videos
                .Include(v => v.Tenant)
                .FirstOrDefaultAsync(v => v.Id == videoId);

            if (video == null)
                throw new ArgumentException("Video not found", nameof(videoId));

            var caption = new Caption
            {
                Id = Guid.NewGuid(),
                VideoId = videoId,
                TenantId = video.TenantId,
                Language = language,
                Format = format,
                Content = content,
                Label = label ?? language.ToUpper(),
                IsAutoGenerated = false,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            _context.Captions.Add(caption);
            await _context.SaveChangesAsync();

            return caption;
        }

        public async Task UpdateCaptionAsync(Guid captionId, string? content = null, string? label = null)
        {
            var caption = await _context.Captions.FindAsync(captionId);
            if (caption == null)
                throw new ArgumentException("Caption not found", nameof(captionId));

            if (content != null) caption.Content = content;
            if (label != null) caption.Label = label;

            caption.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
        }

        public async Task DeleteCaptionAsync(Guid captionId)
        {
            var caption = await _context.Captions.FindAsync(captionId);
            if (caption == null)
                throw new ArgumentException("Caption not found", nameof(captionId));

            _context.Captions.Remove(caption);
            await _context.SaveChangesAsync();
        }

        public async Task<Caption?> GetCaptionAsync(Guid captionId)
        {
            return await _context.Captions
                .Include(c => c.Video)
                .FirstOrDefaultAsync(c => c.Id == captionId);
        }

        public async Task<IEnumerable<Caption>> GetVideoCaptionsAsync(Guid videoId)
        {
            return await _context.Captions
                .Where(c => c.VideoId == videoId)
                .OrderBy(c => c.Language)
                .ThenBy(c => c.Label)
                .ToListAsync();
        }

        public async Task<byte[]> ExportCaptionAsync(Guid captionId, CaptionFormat format)
        {
            var caption = await _context.Captions.FindAsync(captionId);
            if (caption == null)
                throw new ArgumentException("Caption not found", nameof(captionId));

            // Convert to requested format if necessary
            if (caption.Format == format)
            {
                return System.Text.Encoding.UTF8.GetBytes(caption.Content);
            }

            return format switch
            {
                CaptionFormat.VTT => ConvertToVTT(caption.Content),
                CaptionFormat.SRT => ConvertToSRT(caption.Content),
                CaptionFormat.SBV => ConvertToSBV(caption.Content),
                _ => throw new ArgumentException("Unsupported format", nameof(format))
            };
        }

        public async Task<Caption> ImportCaptionAsync(Guid videoId, Stream fileStream, CaptionFormat format, string language, string? label = null)
        {
            using var reader = new StreamReader(fileStream);
            var content = await reader.ReadToEndAsync();

            // Validate and normalize content
            var normalizedContent = format switch
            {
                CaptionFormat.VTT => NormalizeVTT(content),
                CaptionFormat.SRT => NormalizeSRT(content),
                CaptionFormat.SBV => NormalizeSBV(content),
                _ => throw new ArgumentException("Unsupported format", nameof(format))
            };

            return await CreateCaptionAsync(videoId, language, format, normalizedContent, label);
        }

        public async Task<Caption> AutoGenerateCaptionAsync(Guid videoId, string language)
        {
            // Create encoding job for caption generation
            var job = await _videoProcessingService.CreateEncodingJobAsync(videoId, EncodingJobType.CaptionGeneration);
            
            var video = await _context.Videos
                .Include(v => v.Tenant)
                .FirstOrDefaultAsync(v => v.Id == videoId);

            if (video == null)
                throw new ArgumentException("Video not found", nameof(videoId));

            // In a real implementation, this would integrate with speech-to-text services
            // For now, we'll create a placeholder caption
            var placeholderContent = $"WEBVTT\n\n00:00:00.000 --> 00:00:05.000\nAuto-generated caption for {language}\n";

            var caption = new Caption
            {
                Id = Guid.NewGuid(),
                VideoId = videoId,
                TenantId = video.TenantId,
                Language = language,
                Format = CaptionFormat.VTT,
                Content = placeholderContent,
                Label = language.ToUpper(),
                IsAutoGenerated = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            _context.Captions.Add(caption);
            await _context.SaveChangesAsync();

            // Update job status
            await _videoProcessingService.UpdateEncodingJobStatusAsync(job.Id, EncodingJobStatus.Completed);

            return caption;
        }

        public async Task<CaptionTrack> GetCaptionTrackAsync(Guid videoId, string language)
        {
            var captions = await _context.Captions
                .Where(c => c.VideoId == videoId && c.Language == language)
                .OrderBy(c => c.Label)
                .ToListAsync();

            var track = new CaptionTrack
            {
                VideoId = videoId,
                Language = language,
                Captions = captions.Select(c => new CaptionCue
                {
                    Id = c.Id,
                    Start = ParseStartTime(c.Content),
                    End = ParseEndTime(c.Content),
                    Text = ExtractText(c.Content)
                }).OrderBy(cue => cue.Start).ToList()
            };

            return track;
        }

        private byte[] ConvertToVTT(string content)
        {
            if (content.StartsWith("WEBVTT"))
                return System.Text.Encoding.UTF8.GetBytes(content);

            // Convert from SRT to VTT
            var vttContent = "WEBVTT\n\n" + content
                .Replace(",", ".", StringComparison.Ordinal)
                .Replace("-->", "-->", StringComparison.Ordinal);

            return System.Text.Encoding.UTF8.GetBytes(vttContent);
        }

        private byte[] ConvertToSRT(string content)
        {
            if (content.Contains("-->") && !content.StartsWith("WEBVTT"))
                return System.Text.Encoding.UTF8.GetBytes(content);

            // Convert from VTT to SRT
            var lines = content.Split('\n');
            var srtLines = new List<string>();
            int index = 1;

            foreach (var line in lines)
            {
                if (line.Contains("-->"))
                {
                    srtLines.Add(index.ToString());
                    srtLines.Add(line.Replace(".", ",", StringComparison.Ordinal));
                    index++;
                }
                else if (!string.IsNullOrWhiteSpace(line) && !line.StartsWith("WEBVTT"))
                {
                    srtLines.Add(line);
                }
            }

            return System.Text.Encoding.UTF8.GetBytes(string.Join("\n", srtLines));
        }

        private byte[] ConvertToSBV(string content)
        {
            // Convert to YouTube SBV format
            var lines = content.Split('\n');
            var sbvLines = new List<string>();

            foreach (var line in lines)
            {
                if (line.Contains("-->"))
                {
                    var time = line.Replace(".", ",", StringComparison.Ordinal).Replace("-->", ",");
                    sbvLines.Add(time);
                }
                else if (!string.IsNullOrWhiteSpace(line) && !line.StartsWith("WEBVTT"))
                {
                    sbvLines.Add(line);
                }
            }

            return System.Text.Encoding.UTF8.GetBytes(string.Join("\n", sbvLines));
        }

        private string NormalizeVTT(string content)
        {
            if (!content.StartsWith("WEBVTT"))
                content = "WEBVTT\n\n" + content;
            return content;
        }

        private string NormalizeSRT(string content)
        {
            // Ensure SRT format is valid
            return content;
        }

        private string NormalizeSBV(string content)
        {
            // Ensure SBV format is valid
            return content;
        }

        private TimeSpan ParseStartTime(string content)
        {
            // Parse start time from caption content
            var lines = content.Split('\n');
            foreach (var line in lines)
            {
                if (line.Contains("-->"))
                {
                    var timePart = line.Split("-->")[0].Trim();
                    return TimeSpan.Parse(timePart.Replace('.', ':'));
                }
            }
            return TimeSpan.Zero;
        }

        private TimeSpan ParseEndTime(string content)
        {
            // Parse end time from caption content
            var lines = content.Split('\n');
            foreach (var line in lines)
            {
                if (line.Contains("-->"))
                {
                    var timePart = line.Split("-->")[1].Trim();
                    return TimeSpan.Parse(timePart.Replace('.', ':'));
                }
            }
            return TimeSpan.Zero;
        }

        private string ExtractText(string content)
        {
            // Extract text content from caption
            var lines = content.Split('\n');
            var textLines = new List<string>();
            bool isTimeLine = false;

            foreach (var line in lines)
            {
                if (line.Contains("-->"))
                {
                    isTimeLine = true;
                }
                else if (isTimeLine && !string.IsNullOrWhiteSpace(line))
                {
                    textLines.Add(line);
                }
            }

            return string.Join(" ", textLines);
        }
    }

    public class CaptionTrack
    {
        public Guid VideoId { get; set; }
        public string Language { get; set; } = null!;
        public List<CaptionCue> Captions { get; set; } = new();
    }

    public class CaptionCue
    {
        public Guid Id { get; set; }
        public TimeSpan Start { get; set; }
        public TimeSpan End { get; set; }
        public string Text { get; set; } = null!;
    }

    public enum CaptionFormat
    {
        VTT,
        SRT,
        SBV
    }
}
